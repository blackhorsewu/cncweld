/*********1*********2*********3*********4*********5*********6*********7**********
 *                                                                              *
 *     Chinese National Engineering Research Centre for Steel Construction      *
 *                                (Hong Kong Branch)                            *
 *                                                                              *
 * This file, cncweld_core_node.cpp tries to control a CNC Welding machine.     *
 *                                                                              *
 * 1. The CNC machine, driven by stepper motors, are controlled by GRBL running *
 *    on Arduino Mega 2650.                                                     *
 * 2. G-Codes are sent to GRBL instructing it how to move.                      *
 * 3. A Keyence LJ V7200 laser scanner is driven to scan the welding groove.    *
 * 4. Once the welding groove is scanned, a path is worked out for welding.     *
 *                                                                              *
 * To start, GRBL needs to go through a Homing procedure. This will drive the   *
 * CNC device, carrying the welding torch and the laser scanner, to its origin. *
 *                                                                              *
 * Then it will start to report the positions of each joint. That is basically, *
 * the x, y, and z coordinates. A message of this position of the topic grbl_pos*
 * will be published. The joint_state_publisher, subscribes to this topic, will *
 * publish the joint positions using this information. A ROS package, the       *
 * robot_state_publisher, will then use the joint states to workout the robot   *
 * states and publishes them. Another ROS package, tf, will use them to work    *
 * transforms for all the frames at all times and makes them available to all   *
 * subscribing nodes.                                                           *
 *                                                                              *
 * The point clouds of the laser scanner, generated by a Keyence_drive_node,    *
 * will be transformed to the coordinates of the origin of the CNC machine.     *
 * With these transforms, every transformed point cloud will be cumulated to a  *
 * large point cloud covering the whole welding groove.                         *
 *                                                                              *
 * The deepest point of the groove will be highlighted by a marker. The markers *
 * will form the welding path.                                                  *
 *                                                                              *
 ********************************************************************************/

#include <ros/ros.h>
#include <sensor_msgs/JointState.h>

#include <tf/transform_datatypes.h>
#include <tf/transform_listener.h>
#include <tf/transform_broadcaster.h>
#include <sensor_msgs/PointCloud2.h>

#include <pcl_conversions/pcl_conversions.h>
#include "pcl_ros/transforms.h"
#include <pcl_ros/point_cloud.h>

#include <pcl/point_types.h>

#include "boost/bind.hpp"
#include "boost/ref.hpp"

// Visualisation markers
#include <visualization_msgs/Marker.h>
#include <geometry_msgs/Twist.h>
#include <std_msgs/String.h>

// Visual Tools
#include <moveit_visual_tools/moveit_visual_tools.h>
#include <rviz_visual_tools/rviz_visual_tools.h>

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <fstream>

using namespace std;

// ros parameters for GRBL
int xaccel, yaccel, zaccel;
int xmin, ymin, zmin;
int xmax, ymax, zmax;
int xspeed, yspeed, zspeed;
int xsteps, ysteps, zsteps;

// values LJ Navigator uses for out-of-range points (in meters)
const static double KEYENCE_INFINITE_DISTANCE_VALUE_SI = -999.9990 / 1e3;
const static double KEYENCE_INFINITE_DISTANCE_VALUE_SI2 = -999.9970 / 1e3;

// the publishers declared here to be global and used in functions,
// will be initialised in main

ros::Publisher pub;     // publisher for the cumulated cloud
ros::Publisher mkr_pub; // publisher for the deepest points

ros::Publisher grbl_pub; // publisher for moving grbl

int marker_id = 0;

pcl::PointCloud<pcl::PointXYZ> pcl_Y_cloud; // cumulated cloud

// needed for transformation from scanner frame to world frame
std::string sensor_host;
std::string scanner_frame;
std::string world_frame;

// CNC Machine home offsets in mm
// Meaning, when the CNC Machine is homed, ROS reports this position
double home_off_x = 320.0;
double home_off_y = -100.0;
double home_off_z = 93.0;

double target_x = 0.0; // mm

double start_x; // mm; when z moved -40mm from origin
double x_step = 25.0; // mm

double scanningZ = -40; // mm
double midCloudY = 0.0;
double diffY = 0.0;
double laser_torch_off = 4.25; // mm offset between laser and torch
double vert_off = 36; // mm; 

int scanLength = 0; // mm
bool scanDone = false;

struct linearPosition
{
  double x;
  double y;
  double z;
};

vector<linearPosition> wayPoints;

visualization_msgs::MarkerArray dpst_pt_array;

/*
 * Global Variables for Status and Position
 */
enum status { Startup, Alarm, Running, Idle,  OK, Error, Home };
status grblStatus = Startup;
enum hoststatus { G_CodeSent, waitingIdle };
hoststatus hostStatus = waitingIdle;
struct Position
{
    double X;
    double Y;
    double Z;
  
    double A;
    double B;
    double C;
};

bool readyToShow = false;
bool scanStarted = false;
bool firstPoint = true;

std::ofstream myfile;

/*
 * Publish a String topic to grbl_driver to move to the specified position.
 *
 * When moving the CNC Device, there should also be a specified speed.
 */
void move_scanner_to(double x, double y, double z)
{
  geometry_msgs::Twist position;
  double linearX, linearY, linearZ;
  std_msgs::String msg;
  string gcode;
  string grbl_status = "do not know what! ";
  string host_status = "do not know what! ";
  
  if (!scanStarted)
  {
    char c;

    // cout << "Hit enter when ready to start scanning." << endl;
    cout << "Please input scan length in mm (whole digit) when ready" << endl;
    cin >> scanLength;
    c = getchar();
    scanStarted = true;
    start_x = (x - home_off_x);
    cout << "mid cloud y: " << midCloudY << "; deepest y: " << y << endl;
    cout << "midCloudY - deepest y: " << midCloudY - y << endl;
    diffY = y - midCloudY;
    gcode = "G0 X"+to_string(x-home_off_x-start_x) // G0 meaning move quickly
            +" Y"+to_string(y-home_off_y-diffY)
            +" Z"+to_string(50-home_off_z) + "\n";
    msg.data = gcode;
//    cout << gcode;
    grbl_pub.publish(msg);
  }
  else if (!scanDone)
  {
    linearX = x - home_off_x - start_x; // scanner head offset - start_x 

    if (linearX < scanLength)
    {
      if (y <= home_off_y )
      {
        linearY = 0;
      }
      else
      {
        linearY = y - home_off_y - diffY;
      }

      linearZ = 50 - home_off_z; // because the z moves in reverse direction
    
      if (grblStatus == Idle) grbl_status = "Idle";
      if (grblStatus == Running) grbl_status = "Running";
      if (grblStatus == Home) grbl_status = "Home";
      if (hostStatus == waitingIdle) host_status = "Waiting Idle";
      if (hostStatus == G_CodeSent) host_status = "G-Code sent";

      // cout << "Grbl status: " << grbl_status << endl;
      // cout << "Host status: " << host_status << endl;

      if ((hostStatus == waitingIdle) && (grblStatus == Idle)) 
      { // Grbl ready to accept command
        readyToShow = true;
        if (target_x <= 0) target_x = x_step; else target_x = linearX + x_step;
        // ROS_INFO("New Target_x: x: %.3f", target_x);
        linearX = target_x;
        gcode = "G01 F300 X"+to_string(linearX)+
                        " Y"+to_string(linearY)+
                        " Z"+to_string(linearZ)+ "\n";
        msg.data = gcode;
        // cout << gcode;
        grbl_pub.publish(msg);
        hostStatus = G_CodeSent;
        // cout << "G-Code sent." << endl;
      }
    } else
    { // scanning is done
      scanDone = true;
      cout << "Scanning is done, switching laser off and machine going home." << endl;
      gcode = "M9\n"; // switch off laser
      msg.data = gcode;
      grbl_pub.publish(msg);
      hostStatus = G_CodeSent;
      // Go home
      gcode = "$H\n"; // Go home
      msg.data = gcode;
      grbl_pub.publish(msg);
      hostStatus = G_CodeSent;

      cout << "There are " << marker_id << " way points identified." << endl;

      // Before closing the file, make sure the torch is taken up immediately
      myfile << "M5 (Switch off the torch)" << endl;
      myfile << "G0 Z0" << endl;
      myfile << "G0 X0 Y0 Z0" << endl;
      myfile.close();
    }
  }
}

void publish_deepest_pt(pcl::PointXYZ deepest_point)
{
  // setup deepest point Marker message
  visualization_msgs::Marker dpst_pt; 
  dpst_pt.header.frame_id = world_frame;
  dpst_pt.header.stamp = ros::Time();
  dpst_pt.ns = "dpst_pt";
  dpst_pt.action = visualization_msgs::Marker::ADD;
  dpst_pt.pose.orientation.w = 1.0; // Quarternion
  dpst_pt.id = marker_id++; // This should be incremented by an number counting number of points published
  dpst_pt.type = visualization_msgs::Marker::SPHERE;
  dpst_pt.scale.x = 0.003; // so the line is shown as of 0.1mm wide
  dpst_pt.scale.y = 0.003;
  dpst_pt.scale.z = 0.003;
  dpst_pt.color.r = 1;   // in red
  dpst_pt.color.a = 1;   //

  linearPosition wayPoint;

  // set the location of the deepest point
  dpst_pt.pose.position.x = deepest_point.x;
  dpst_pt.pose.position.y = deepest_point.y;
  dpst_pt.pose.position.z = deepest_point.z;

  wayPoint.x = deepest_point.x;
  wayPoint.y = deepest_point.y;
  wayPoint.z = deepest_point.z;

  wayPoints.push_back(wayPoint);

  if (readyToShow)
  {
//    dpst_pt_array.markers.push_back(dpst_pt);
    // publish the point as a marker in RViz
    mkr_pub.publish(dpst_pt);
    if (firstPoint)
    {
      myfile  << "G0(quickly) X" 
              << (deepest_point.x*1e3-home_off_x-start_x) << " Y" 
              << (deepest_point.y*1e3-home_off_y-diffY-laser_torch_off) << " Z0" << endl;
      myfile  << "G0(quickly) X" 
              << (deepest_point.x*1e3-home_off_x-start_x) << " Y" 
              << (deepest_point.y*1e3-home_off_y-diffY-laser_torch_off) << " Z" 
              << (vert_off-home_off_z) << endl;
      myfile  << "M3 (Switch on the torch)" << endl;
      myfile  << "G04 P1 (Wait 1 second for Arc to start)" << endl;
      firstPoint = false;
    }
    else
    {
      myfile  << "G01 F300 X"
              << (deepest_point.x*1e3-home_off_x-start_x) << " Y" 
              << (deepest_point.y*1e3-home_off_y-diffY-laser_torch_off) << " Z" 
              << (vert_off-home_off_z) << endl;
    }
  }
}

/*
 * Find the deepest point of the input scan line (a cross section of the groove).
 * move to that point.
 */
void deepest_pt(pcl::PointCloud<pcl::PointXYZ> pointcloud)
{
  int cloudSize = pointcloud.size();

  double minZ = 100.0;
  double x = 0.0;
  double y = 0.0;
  double z = 0.0;

  int dpst = 0;

  midCloudY = pointcloud[cloudSize/2].y * 1e3;

  for (int i = 0; i < (cloudSize); ++i) // Ignore the first 50 points
  {
    z = pointcloud[i].z;
    // Check to make sure the point is a valid point, some points may be invalid
    if ((z != KEYENCE_INFINITE_DISTANCE_VALUE_SI) && (z != KEYENCE_INFINITE_DISTANCE_VALUE_SI2)
          && (z != std::numeric_limits<double>::infinity()))
    {   // then this is a piece of normal point
      if (z < minZ)
      {
        minZ = z;
        dpst = i;
      }
    }
  }

  x = pointcloud[dpst].x * 1e3;
  y = pointcloud[dpst].y * 1e3;
  z = pointcloud[dpst].z * 1e3;

  if (((z != KEYENCE_INFINITE_DISTANCE_VALUE_SI) && (z != KEYENCE_INFINITE_DISTANCE_VALUE_SI2)
        && (z != std::numeric_limits<double>::infinity())) &&
     ((y != KEYENCE_INFINITE_DISTANCE_VALUE_SI) && (y != KEYENCE_INFINITE_DISTANCE_VALUE_SI2)
        && (z != std::numeric_limits<double>::infinity())) &&
     ((x != KEYENCE_INFINITE_DISTANCE_VALUE_SI) && (x != KEYENCE_INFINITE_DISTANCE_VALUE_SI2)
        && (z != std::numeric_limits<double>::infinity())))   
  {   // then this is a normal point
    // ROS_INFO("Deepest Point: x: %.2f y: %.2f z: %.2f ", x, y, z );

    move_scanner_to(x, y, z);
    // There should be another one to move the torch to.
    // The difference is the position in the z direction.

    publish_deepest_pt(pointcloud[dpst]);
  }
}

/*
 * This handles one scan line, published by the scanner driver.
 * Transform it to world coordinate, publish the concatenated point cloud so far.
 */
void callback(const sensor_msgs::PointCloud2ConstPtr& ros_cloud)
{
  // The publisher is initialised in main
  pcl::PointCloud<pcl::PointXYZ> pcl_cloud;

  // Only ros cloud can be transformed!
  tf::TransformListener listener;
  tf::StampedTransform  stransform;

  try
  {
    listener.waitForTransform(world_frame,
                              ros_cloud->header.frame_id,
                              ros::Time::now(),
                              ros::Duration(0.75));
    listener.lookupTransform (world_frame,
                              ros_cloud->header.frame_id,
                              ros::Time(0),
                              stransform);
  }
  catch (tf::TransformException ex)
  {
    ROS_ERROR("%s",ex.what());
  }

  sensor_msgs::PointCloud2 transformed_ros_cloud;
  pcl_ros::transformPointCloud(world_frame,
                               stransform,
                               *ros_cloud,
                               transformed_ros_cloud);
  /*
   * pcl cloud is used because the operator += cannot work with ros cloud!
   */
  pcl::fromROSMsg(transformed_ros_cloud, pcl_cloud);
  pcl_Y_cloud.header.frame_id = pcl_cloud.header.frame_id; // cannot be done away with; must keep
  deepest_pt(pcl_cloud); // try to find the deepest point of this cross section
  if (readyToShow)
  {
    pcl_Y_cloud += pcl_cloud; // concatenate the front line to the cumulated point cloud
    pub.publish(pcl_Y_cloud);
  }
}

int getrosparams(ros::NodeHandle pnh)
{
  pnh.getParam("x_accel", xaccel);
  pnh.getParam("y_accel", xaccel);
  pnh.getParam("z_accel", xaccel);

  pnh.getParam("x_min", xmin);
  pnh.getParam("y_min", ymin);
  pnh.getParam("z_min", zmin);

  pnh.getParam("x_max", xmax);
  pnh.getParam("y_max", zmax);
  pnh.getParam("z_max", zmax);

  pnh.getParam("x_max_speed", xspeed);
  pnh.getParam("y_max_speed", yspeed);
  pnh.getParam("z_max_speed", zspeed);

  pnh.getParam("x_steps", xsteps);
  pnh.getParam("y_steps", ysteps);
  pnh.getParam("z_steps", zsteps);

  return(1);
}

void statCb(std_msgs::String msg)
{
  // cout << "Grbl status received: " << msg.data << endl;
  if (msg.data == "Home")
  {
    // cout << "I am here (1)." << endl;
    // In the beginning, Status was Startup. When it turns to OK meaning Homing is done.
    if (grblStatus == Startup) // grblStatus was Startup and now Homed ready to switch on laser
    {
      std_msgs::String out_msg;
//      out_msg.data = "G0 X0 Y100 Z0\n";
//      grbl_pub.publish(out_msg);
      char c;
      cout << "Hit enter when ready to switch on laser." ;
      c = getchar();
      // move the scanner down by 40 mm first
      out_msg.data = "G0 X0 Y100 Z-40\n";
      grbl_pub.publish(out_msg);
      // then switch on the laser
      out_msg.data = "M8\n";
      grbl_pub.publish(out_msg);
      // cout << "grbl_pub published: " << out_msg.data << endl;
    }
    grblStatus = Home;
  } 
  // cout << "I am here (2)." << endl;
  if (msg.data == "Idle") grblStatus = Idle;
  if (msg.data == "Run")
  {
    grblStatus = Running;
    if (hostStatus == G_CodeSent) hostStatus = waitingIdle;
  }
}

int main(int argc, char* argv[])
{
  ros::init(argc, argv, "cncweld_core_node");
  ros::NodeHandle nh, pnh("~");

  // Point Cloud topic
  std::string cloud_topic;

  std_msgs::String msg;

  cloud_topic = "profiles"; // The cloud published by the Keyence Driver
  world_frame = "world";
  scanner_frame = "lj_v7200_optical_frame";

  myfile.open("grbl.gcode");

  myfile << "(G-Code file generated by CNCWeld)" << endl; // comments in ()
  myfile << "$H" << "(Home before doing anything)" << endl;

  // profile cloud publisher for PCL point clouds
  pub = nh.advertise<pcl::PointCloud<pcl::PointXYZ>>("Y_profiles", 1);

  // deepest point marker publisher
  mkr_pub = nh.advertise<visualization_msgs::Marker>("deepest_point", 0);

  grbl_pub = nh.advertise<std_msgs::String>("grbl_cmd", 1);

  std::string topic = nh.resolveName(cloud_topic);

  while (ros::ok)
  {
    // Need to start subscribing to grbl status first otherwise will not know its status
    // to proceed.
    ros::Subscriber status_sub = nh.subscribe<std_msgs::String>("grbl_status", 10, statCb);

    // Only subscribe to the scanner point cloud AFTER homing
    // otherwise, no tf between world and lj_v7200_optical_frame
    // Actually, now the laser is off on startup and will only switch on by user
    ros::Subscriber sub = nh.subscribe<sensor_msgs::PointCloud2>(topic, 1, callback);
    ros::spin();
  }

  msg.data = "stop";
  grbl_pub.publish(msg);
}
