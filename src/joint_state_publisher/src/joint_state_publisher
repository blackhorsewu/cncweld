#!/usr/bin/python

from ntpath import join
import roslib
# ; roslib.load_manifest('clam_controller')
import rospy
import wx
import xml.dom.minidom
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Twist
from math import pi
from threading import Thread

RANGE = 10000

def get_param(name, value=None):
    private = "~%s" % name
    if rospy.has_param(private):
        return rospy.get_param(private)
    elif rospy.has_param(name):
        return rospy.get_param(name)
    else:
        return value

class JointStatePublisher():
    def __init__(self):
        description = get_param('robot_description')
        # I do not understand the statement below!
        robot = xml.dom.minidom.parseString(description).getElementsByTagName('robot')[0]
        self.free_joints = {}
        self.joint_list = [] # for maintaining the original order of the joints
        self.dependent_joints = get_param("dependent_joints", {})
        
        # Find all non-fixed joints
        for child in robot.childNodes:
            if child.nodeType is child.TEXT_NODE:
                continue
            if child.localName == 'joint':
                jtype = child.getAttribute('type')
                if jtype == 'fixed':
                    continue
                name = child.getAttribute('name')
                if jtype == 'continuous':
                    minval = -pi
                    maxval = pi
                else:
                    limit = child.getElementsByTagName('limit')[0]
                    minval = float(limit.getAttribute('lower'))
                    maxval = float(limit.getAttribute('upper'))

                if name in self.dependent_joints:
                    continue
                if minval > 0 or maxval < 0:
                    zeroval = (maxval + minval)/2
                else:
                    zeroval = 0

                joint = {'min':minval, 'max':maxval, 'zero':zeroval, 'value':zeroval }
                self.free_joints[name] = joint
                self.joint_list.append(name)

        # This node originally was designed to cater for a list of joint position
        # sources. It will then subscribe to every member of the list of sources.
        # In our case, we only have one source, that is the Twist message from
        # cnc_interface. Therefore, we do not need to have source_list. It only need to
        # Subscribe to the topic published by cnc_interface: /cnc_interface/position
        #
        # source_list = get_param("source_list", [])
        # self.sources = []
        # for source in source_list:
        #     self.sources.append(rospy.Subscriber(source, JointState, self.source_cb))
        #
        # We have only one source, from cnc_interface. That will publish a topic
        # /cnc_interface/position of type Twist, that contains both position and orientation.
        # Therefore, it is only necessary to subscribe to this topic.
        # So, declare a subscriber to this topic in the statement below:
        # rospy.Subscriber('cnc_interface/position', Twist, self.source_cb)
        rospy.Subscriber('grbl_pos', Twist, self.source_cb)

        # Declare a publisher for the topic /joint_states, of type JointState.
        self.pub = rospy.Publisher('joint_states', JointState)

    # Because it is not a General Purpose node as the original to cater for every 
    # possible urdf. We only need to work with our own CNC Device which only has 4 dof.
    # There are 4 joints:
    # 1. base_link_X_link_joint, prismatic.
    # 2. X_link_Y_link_joint, prismatic.
    # 3. Y_link_Z_link_joint, prismatic.
    # 4. Z_link_tool0, revolute.
    #
    # When a message of the topic /cnc_interface/position is received, take the value of the
    # position of each of the 4 movable joints, listed above, and put them into each elements
    # of the joint_list.
    def source_cb(self, msg): # The msg here should be of type Twist
        # Note: The /cnc_interface/position Twist message uses unit mm
        # while ROS uses unit m, therefore it is necessary to divide by 1,000.
        joint = self.free_joints['base_link_X_link_joint']
        joint['value'] = (msg.linear.x+90)/1000.0
        joint = self.free_joints['X_link_Y_link_joint']
        joint['value'] = msg.linear.y/1000.0
        joint = self.free_joints['Y_link_Z_link_joint']
        joint['value'] = msg.linear.z/1000.0
        joint = self.free_joints['Z_link_tool0']
        joint['value'] = msg.angular.x/1000.0

    def loop(self):
        hz = get_param("rate", 10) # 10hz
        r = rospy.Rate(hz) 

        # Publish Joint States
        while not rospy.is_shutdown(): # keep on publishing until shutdown
            # Construct a message of type JointState
            msg = JointState()
            msg.header.stamp = rospy.Time.now()

            # Add Free Joints
            for (name,joint) in self.free_joints.items():
                msg.name.append(str(name))
                msg.position.append(joint['value'])

            # Add Dependent Joints
            for (name,param) in self.dependent_joints.items():
                parent = param['parent']
                baseval = self.free_joints[parent]['value']
                value = baseval * param.get('factor', 1)

                msg.name.append(str(name))
                msg.position.append(value)

            self.pub.publish(msg)

            r.sleep()

if __name__ == '__main__':
    try:
        print( "my version of jsp." )
        rospy.init_node('joint_state_publisher')
        jsp = JointStatePublisher()
        jsp.loop()
        
    except rospy.ROSInterruptException: pass

